---
title: "6809"
aliases: 
tags: 
- cosc204
---


# Routines
All variables are global so there is no params or local vars. 

There are three way to "Branch" to a subroutine.
- lbsr
- bsr
- jsr

There are subtle differences but we will use bsr mostly

```
bsr myroutine:

myroutine:
	rts
```

# Iteration
Done using GOTOs
```
	clra           //A = 0
more:
	cmpa #$06      //compare A to $06 (sets the equal flag in CC if true)
	beq done       //if the equal flag is set, branch to done
	inca           //increment a
	bra more       //branch to more
done:
```

other instructions set flags too

# Input/Output
![screen](https://i.imgur.com/IEiGKtj.png)

The screen always displays whatever is in the "screens memory location" which is $0400

``` 6809 assembly
lda #'H'          ; load the character (indicated by '') into the a register
sta $0400         ; store the contents of the a register in memory at location $0400
```

## printing a whole string

```
message:
	.byte "HELLO WORLD", 0

START:
	ldy #message                                 ; load 
	bsr puts                                     ; branch to the "puts" subroutine
	rts                                          ; return

; Routine: PUTS 
; Pass the address of the string in Y 
; 
screen EQU $0400      ; start of screen 

PUTS: 
	pshs a,x,y        ; save a, x, and y          ; store the contents of the a, x, and y registers so they are not overwritten
	ldx #screen       ; start of screen           ; load the hex value of the memory location of the screen ($0400) into the x register
more: 
	lda 0,y+          ; current char -> A         ; load 
	cmpa #$00         ; was it a zero? 
	beq done          ; if it was 0 then return 
	sta 0,x+          ; write 
	bra more          ; repeat 
done: 
	puls a,x,y        ; restore a, x, y 
	rts               ; return from this routine
```

# Hello World

# Assembler

